内存分配
    方法区：方法区存放的是类信息、常量、静态变量，所有线程共享区域。
    虚拟机栈：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、
  方法出口等信息，线程私有区域。
    本地方法栈：与虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的Native方法服务。
    堆：JVM管理的内存中最大的一块，所有线程共享；用来存放对象实例，几乎所有的对象实例都在堆上分配内存；此区域也是
  垃圾回收器（Garbage Collection）主要的作用区域，内存泄漏就发生在这个区域。
    程序计数器：可看做是当前线程所执行的字节码的行号指示器；如果线程在执行Java方法，这个计数器记录的是正在执行的
  虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。

内存回收
    1、标记-清除算法
        最基础的收集算法：分为“标记”和“清除”两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。
        这种方法有两个不足点：
            效率问题，标记和清除两个过程的效率都不高；
            空间问题，标记清除之后会产生大量的不连续的内存碎片
    2、复制算法
        将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另
      一块内存上面，然后再把已使用过的内存空间一次清理掉。
        这种方法的特点：
            优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，
          只要移动堆顶指针，按顺序分配内存即可；
            缺点：粗暴的将内存缩小为原来的一半，代价实在有点高。
    3、标记-整理算法
        先标记需要回收的对象（标记过程与“标记-清除”算法一样），然后把所有存活的对象都向一端移动，然后直接清理
      掉端边界以外的内存。
        这种方法的特点：
            避免了内存碎片；
            避免了“复制”算法50%的空间浪费；
            主要针对对象存活率高的老年代。
    4、分代收集算法
        根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点
      采用最适当的收集算法。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，那就选用复制算法，
      只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，
      就必须使用标记—清除算法或标记—整理算法来进行回收。

对象是否回收的依据
    1、引用计数算法
    2、可达性分析算法

Android的内存管理
    1、限制应用的内存
        为了整个Android系统的内存控制需要，Android系统为每一个应用程序都设置了一个硬性的Dalvik Heap Size
      最大限制阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果你的应用占用内存空间已经接近这个阈值，
      此时再尝试分配内存的话，很容易引起OutOfMemoryError的错误。
        ZHU yuyang ActivityManager.getMemoryClass()可以用来查询当前应用的Heap Size阈值，这个方法会返回一个整数，
      表明你的应用的Heap Size阈值是多少Mb(megabates)。
    2、应用切换
        Android系统并不会在用户切换应用的时候做交换内存的操作。Android会把那些不包含Foreground组件的应用进程
      放到LRU Cache中。例如，当用户开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并
      不会立即被销毁，而是会被放到系统的Cache当中，如果用户后来再切换回到这个应用，此进程就能够被马上完整的恢复，
      从而实现应用的快速切换。
        如果你的应用中有一个被缓存的进程，这个进程会占用一定的内存空间，它会对系统的整体性能有影响。因此当系统开始
      进入Low Memory的状态时，它会由系统根据LRU的规则与应用的优先级，内存占用情况以及其他因素的影响综合评估之后
      决定是否被杀掉。

        在Dalvik下，大部分Davik采取的都是标记-清理回收算法，而且具体使用什么算法是在编译期决定的，无法在运行的
      时候动态更换。标记-清理回收算法无法对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap
      的尾端剩余空间是否足够，如果空间不够会触发gc操作，从而腾出更多空闲的内存空间；这样内存空洞就产生了。
        ART在GC上不像Dalvik仅有一种回收算法，ART在不同的情况下会选择不同的回收算法。应用程序在前台运行时，
      响应性是最重要的，因此也要求执行的GC是高效的。相反，应用程序在后台运行时，响应性不是最重要的，这时候就适合
      用来解决堆的内存碎片问题。因此，Mark-Sweep GC适合作为Foreground GC，而Mark-Compact GC适合作为
      Background GC。由于有Compact的能力存在，内存碎片在ART上可以很好的被避免，这个也是ART一个很好的能力。

Android GC何时发生
    GC操作主要是由系统决定的，但是我们可以监听系统的GC过程，以此来分析我们应用程序当前的内存状态。
    1、Dalvik虚拟机，每一次GC打印内容格式：
        D/dalvikvm: <GC_Reason> <Amount_freed>, <Heap_stats>, <External_memory_stats>, <Pause_time>
      含义解析
        *GC Reason：GC触发原因
            GC_CONCURRENT：当已分配内存达到某一值时，触发并发GC；
            GC_FOR_MALLOC：当尝试在堆上分配内存不足时触发的GC；系统必须停止应用程序并回收内存；
            GC_HPROF_DUMP_HEAP： 当需要创建HPROF文件来分析堆内存时触发的GC；
            GC_EXPLICIT：当明确的调用GC时，例如调用System.gc()或者通过DDMS工具显式地告诉系统进行GC操作等；
            GC_EXTERNAL_ALLOC： 仅在API级别为10或者更低时（新版本分配内存都在Dalvik堆上）
        *Amount freed GC：回收的内存大小
        *Heap stats：堆上的空闲内存百分比 （已用内存）/（堆上总内存）
        *External memory stats： API级别为10或者更低：（已分配的内存量）/ （即将发生垃圾的极限）
        *Pause time：这次GC操作导致应用程序暂停的时间。关于这个暂停的时间，在2.3之前GC操作是不能并发进行的，
            也就是系统正在进行GC，那么应用程序就只能阻塞住等待GC结束。而自2.3之后，GC操作改成了并发的方式进行，
            就是说GC的过程中不会影响到应用程序的正常运行，但是在GC操作的开始和结束的时候会短暂阻塞一段时间。
    2、Art虚拟机，每一次GC打印内容格式：
        I/art:<GC_Reason><Amount_freed>,<LOS_Space_Status>,<Heap_stats>,<Pause_time>,<Total_time>
      基本情况和Dalvik没有什么差别，GC的Reason更多了，还多了一个LOS_Space_Status.
        LOS_Space_Status：Large Object Space，大对象占用的空间，这部分内存并不是分配在堆上的，但仍属于应用程序
      内存空间，主要用来管理 Bitmap 等占内存大的对象，避免因分配大内存导致堆频繁 GC。